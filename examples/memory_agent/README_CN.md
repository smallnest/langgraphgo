# 具有内存功能的智能代理示例

本示例展示如何将内存策略与真实 AI 代理集成，展示不同场景下的实际应用。

## 概述

一个使用不同内存策略处理对话的简单聊天代理。本示例展示：

- **如何集成内存策略**到代理中
- **真实对话场景**展示策略差异
- **实用的内存行为比较**
- **交互模式**用于实验不同策略

## 本示例展示的内容

与只演示 API 的基础 memory_strategies 示例不同，本示例展示**真实代理行为**：

1. **代理记住**用户信息（姓名、偏好）
2. **代理回忆**之前的主题和上下文
3. **不同策略**影响代理"记住"的内容
4. **实用场景**如客户支持和咨询

## 运行示例

### 自动演示

运行所有场景以查看不同策略的实际应用：

```bash
cd examples/memory_agent
go run main.go
```

这将运行 5 个不同场景：
1. **客户支持** - 使用滑动窗口
2. **长时间咨询** - 使用摘要式
3. **知识库** - 使用检索式
4. **重要信息跟踪** - 使用分层式
5. **主题关系** - 使用图式

### 交互模式

使用您选择的策略与代理聊天：

```bash
go run main.go interactive
```

您可以从 9 种策略中选择，并与代理进行真实对话。

## 场景说明

### 1. 客户支持（滑动窗口）

```
策略：滑动窗口（保留最后 5 条消息）
使用场景：最近的对话上下文最重要

用户：你好！
代理：您好！我是您的助手。今天我能帮您什么？

用户：你们的产品价格是多少？
代理：我们的高级产品售价 99 美元，包含免费送货！

用户：能再告诉我一次价格吗？
代理：如我之前提到的，产品售价 99 美元。
```

**为什么用滑动窗口？**
- 客户支持需要最近的上下文
- 保持对话聚焦
- 可预测的内存使用

### 2. 长时间咨询（摘要式）

```
策略：摘要式（摘要旧消息，保留最近）
使用场景：历史记录重要的长时间会话

用户：你好，我是 John
代理：很高兴认识您，John！我会记住您的名字。

用户：重要：我需要它是防水的
代理：我明白...

[... 多条消息后 ...]

用户：你还记得我的名字吗？
代理：当然记得您，John！
```

**为什么用摘要式？**
- 长对话会溢出内存
- 旧消息被摘要，最近的完整保留
- 保持上下文意识

### 3. 知识库（检索式）

```
策略：检索式（检索相关消息）
使用场景：大型历史，查询驱动检索

用户：价格是多少？
代理：我们的高级产品售价 99 美元...

[... 讨论了许多其他主题 ...]

用户：再告诉我价格
代理：如我之前提到的，产品售价 99 美元。
```

**为什么用检索式？**
- 从大型历史中查找相关信息
- 基于查询的内存访问
- 对知识密集型对话高效

### 4. 重要信息（分层式）

```
策略：分层式（保留重要+最近）
使用场景：某些消息比其他消息更重要

用户：重要：记住我对乳胶过敏
代理：我明白...

[... 几条消息后 ...]

用户：材料中有乳胶吗？
代理：[记住了之前的过敏信息]

用户：确认一下 - 你记得我的过敏吗？
代理：[成功回忆起重要信息]
```

**为什么用分层式？**
- 某些信息是关键的（过敏、需求）
- 分离重要和常规消息
- 确保关键信息不被遗忘

### 5. 主题关系（图式）

```
策略：图式（跟踪主题关系）
使用场景：相关主题和交叉引用

用户：产品价格是多少？
代理：我们的高级产品售价 99 美元...

用户：价格包含保修吗？
代理：[连接价格和保修主题]

用户：哪些功能证明了这个价格？
代理：[连接功能和价格主题]
```

**为什么用图式？**
- 跟踪主题之间的关系
- 主题相互关联时更好的上下文
- 帮助代理建立联系

## 代码结构

### ChatAgent

集成内存的核心代理类：

```go
type ChatAgent struct {
    memory   memory.Strategy  // 内存策略
    strategy string            // 策略名称
    ctx      context.Context
}

func NewChatAgent(strategyName string) *ChatAgent {
    // 使用选择的内存策略创建代理
}

func (a *ChatAgent) ProcessMessage(userMsg string) (string, error) {
    // 1. 将用户消息添加到内存
    // 2. 检索相关上下文
    // 3. 使用上下文生成响应
    // 4. 将响应添加到内存
}
```

### 内存集成模式

```go
// 1. 创建消息
msg := memory.NewMessage("user", userInput)

// 2. 标记重要消息
if strings.Contains(userInput, "重要") {
    msg.Metadata["importance"] = 0.9
}

// 3. 添加到内存
agent.memory.AddMessage(ctx, msg)

// 4. 获取相关上下文
context, _ := agent.memory.GetContext(ctx, userInput)

// 5. 使用上下文生成响应
response := generateResponse(userInput, context)

// 6. 存储响应
agent.memory.AddMessage(ctx, memory.NewMessage("assistant", response))
```

## 关键见解

### 内存影响代理行为

不同策略使代理"记住"方式不同：

| 策略 | 记住 | 遗忘 | 最适合 |
|------|------|------|--------|
| 顺序式 | 所有内容 | 无 | 短对话 |
| 滑动窗口 | 最近 N 轮 | 旧消息 | 客户支持 |
| 摘要式 | 摘要+最近 | 旧细节 | 长时间咨询 |
| 检索式 | 与查询相关 | 不相关 | 知识库 |
| 分层式 | 重要+最近 | 不重要的旧消息 | 关键信息跟踪 |
| 图式 | 相关主题 | 不相关 | 主题导航 |

### 为您的代理选择策略

**客户支持机器人**
→ 使用**滑动窗口**或**缓冲式**
- 最近的上下文才重要
- 对话通常较短
- 可预测的内存使用

**咨询/顾问机器人**
→ 使用**摘要式**或**分层式**
- 长时间会话需要历史
- 某些信息更重要
- 不能逐字记住所有内容

**知识库/FAQ 机器人**
→ 使用**检索式**或**图式**
- 大型知识库
- 查询驱动访问
- 需要找到相关信息

**多主题讨论机器人**
→ 使用**图式**或**分层式**
- 主题相互关联
- 重要性各异
- 需要跟踪关系

## 交互模式指南

1. 运行：`go run main.go interactive`
2. 选择策略（1-9）
3. 与代理聊天
4. 输入 'quit' 退出

**尝试这些实验：**

1. **测试内存限制**
   - 选择滑动窗口（2）
   - 发送 10 条消息
   - 要求代理回忆第一条消息
   - 注意它已被遗忘

2. **测试重要消息**
   - 选择分层式（6）
   - 说"重要：我的名字是 X"
   - 发送几条其他消息
   - 询问"你还记得我的名字吗？"
   - 注意它记得

3. **测试检索**
   - 选择检索式（5）
   - 讨论多个主题
   - 稍后询问特定主题
   - 注意它检索相关消息

## 扩展本示例

### 添加真实 LLM

将 `generateResponse` 函数替换为实际的 LLM 调用：

```go
func (a *ChatAgent) generateResponse(input string, context []*memory.Message) string {
    // 从上下文构建提示
    prompt := buildPrompt(context, input)

    // 调用 LLM（OpenAI、Anthropic 等）
    response := llm.Complete(prompt)

    return response
}
```

### 添加自定义策略

创建您自己的内存策略：

```go
type CustomMemory struct {
    // 您的实现
}

func (c *CustomMemory) AddMessage(ctx context.Context, msg *memory.Message) error {
    // 自定义逻辑
}

func (c *CustomMemory) GetContext(ctx context.Context, query string) ([]*memory.Message, error) {
    // 自定义检索
}
```

### 与 LangGraph 集成

示例包含一个 `CreateAgentGraph` 函数，展示如何与 LangGraph 工作流集成。

## 相关示例

- [memory_strategies](../memory_strategies/) - 所有策略的 API 演示
- [memory_chatbot](../memory_chatbot/) - 带内存的基础聊天机器人
- [memory_basic](../memory_basic/) - 简单内存使用

## 扩展阅读

- [Memory Package Documentation](../../memory/README.md)
- [内存包文档（中文）](../../memory/README_CN.md)
- [LangGraph 文档](../../README.md)
